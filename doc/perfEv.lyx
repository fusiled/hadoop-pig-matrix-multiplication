#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\columnsep 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Matrix Multiplication Benchmarking on Hadoop with Pig
\end_layout

\begin_layout Author
Davide Azzalini, Matteo M.
 Fusi
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Purpose
\end_layout

\begin_layout Standard
This document is intended to analize the scaling capability of the Hadoop
 framework using Pig.
 Matrix multiplication will be employed as benchmark.
 The document will also describe how to set the environment up.
\end_layout

\begin_layout Subsection
Document Organization
\end_layout

\begin_layout Standard
Section 1 describes the purpose of the document and furnishes other general
 informations.
 Section 2 describes the installation of the environment.
 Section 3 describes the test execution and how we collected the data.
 Section 4 sums up the results, what we observed and what should be done
 to improve the results or for further research.
 The appendices integrate the document.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reference-Links"

\end_inset

Reference Links
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Repository
\begin_inset space ~
\end_inset

of
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

project 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/fusiled/hadoop-pig-matrix-multiplication-benchmark"

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Ansible 
\begin_inset CommandInset href
LatexCommand href
target "https://www.ansible.com/"

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\emph on
ansible-cloudera-hadoop
\begin_inset space ~
\end_inset


\emph default
Repository
\begin_inset space ~
\end_inset

by
\begin_inset space ~
\end_inset


\emph on
sergevs
\emph default
 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/sergevs/ansible-cloudera-hadoop"

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Hadoop
\begin_inset space ~
\end_inset

Pig 
\begin_inset CommandInset href
LatexCommand href
target "https://pig.apache.org/"

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
OpenStack 
\begin_inset CommandInset href
LatexCommand href
target "https://www.openstack.org/"

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PoliCloud 
\begin_inset CommandInset href
LatexCommand href
target "http://policloud.polimi.it/"

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Raw
\begin_inset space ~
\end_inset

Yarn
\begin_inset space ~
\end_inset

logs
\begin_inset space ~
\end_inset

and
\begin_inset space ~
\end_inset

test
\begin_inset space ~
\end_inset

matrices
\begin_inset space ~
\end_inset

archive (7z format)
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://drive.google.com/file/d/0B8vc7cpy6aOcRGVDTHN2ZlVTbnM/view?usp=sharing"

\end_inset


\end_layout

\begin_layout Section
Setting the Environment Up
\end_layout

\begin_layout Subsection
Architecture
\end_layout

\begin_layout Standard
On top of OpenStack we ran a Master and and a variable number of workers.
 Master was set as namenode.
 Also yarn and Pig were running on it.
 Also Master contributes on job execution.
 Figure 1 shows how the architecture will be at the end of the installation.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/deployment.png
	width 10cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Deployment Diagram of the cluster
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Available Resources
\end_layout

\begin_layout Standard
The Hadoop cluster was deployed on PoliCloud platform, the cloud structure
 hosted and managed by the Politecnico di Milano.
 PoliCloud is a IaaS built on top of OpenStack.
 The available resources were the following:
\end_layout

\begin_layout Itemize
Max number of instances: 8
\end_layout

\begin_layout Itemize
Number of virtual CPUs (VCPUs): 16
\end_layout

\begin_layout Itemize
Available RAM: 21 GB
\end_layout

\begin_layout Itemize
Available persistent storage: 500 GB
\end_layout

\begin_layout Itemize
Max number of volumes: 10
\end_layout

\begin_layout Subsection
Installation
\end_layout

\begin_layout Standard
This Section describe the installation of the cluster on the PoliCloud environme
nt.
 The entry point of PoliCloud for users is a dashboard reachable by the
 web.
 From this dashboard you can easily launch instances.
 After you've launched instances it is required to SSH the machines to begin
 the installation of the cluster.
\end_layout

\begin_layout Subsubsection
Requirements
\end_layout

\begin_layout Standard
A minimal knowledge of Unix shell environment is required to understand
 what the scripts do.
 The knowldege of SSH key management is requested.
 The scripts are anyway thoroughly commented.
 A knowledge of the RedHat/Fedora systems is recommended but not requested
 to understand what 
\emph on
yum 
\emph default
(the package manager of CentOS) command does.
\end_layout

\begin_layout Subsubsection
Run the Instances
\end_layout

\begin_layout Standard
To launch an instance, select a flavour, an OS image and a SSH public key
 for the access.
 Flavours are a sort of predefined 
\begin_inset Quotes eld
\end_inset


\emph on
virtual hardware configurations
\emph default

\begin_inset Quotes erd
\end_inset

.
 You can select only predefined flavours, but you can use any valid OS image.
 You can also save instance images that can be reused in the future.
 Every instance ran CentOS 6 as operating system.
 The image of CentOS 6 is made available by the PoliCloud Environment.
 We allocated the resources in the following way:
\end_layout

\begin_layout Description
Master A single instance with flavour 
\emph on
compute.large
\emph default
, which means 8 VCPUs and 4GB RAM and a disk 80GB big.
\end_layout

\begin_layout Description
Worker Multiple instances (from 2 to 7), each one was a 
\emph on
general.small
\emph default
 flavour, which means 1 VCPUs and 2GB RAM and a disk 20 GB big.
\end_layout

\begin_layout Standard
It's important to highlight that, due to a bug, during the initializiation,
 the instance was not always able to load the key for the SSH access.
 We solved this issue by trial: we kept launching instances until one loaded
 the keys correctly, then we replicated that instance several times.
 The image offered by PoliCloud had also the firewall 
\emph on
iptables
\emph default
 running by default.
 This one must be disabled with Algorithm 1.
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=bash,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

sudo su -
\end_layout

\begin_layout Plain Layout

/etc/init.d/iptables save
\end_layout

\begin_layout Plain Layout

/etc/init.d/iptables stop
\end_layout

\begin_layout Plain Layout

chkconfig iptables off
\end_layout

\begin_layout Plain Layout

exit
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
How to disable the 
\emph on
iptables 
\emph default
firewall
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Installation Script
\end_layout

\begin_layout Standard
We used the a tool created by 
\emph on
sergevs
\emph default
 that is based on Ansible (Check the link at Section 
\emph on

\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Reference-Links"

\end_inset


\emph default
 for further details).
 You can easily clone the linked repository with git.
 The requirements for every machine are:
\end_layout

\begin_layout Enumerate
CentOS 6
\end_layout

\begin_layout Enumerate
Oracle Java installed
\end_layout

\begin_layout Enumerate
Access to the Cloudera 5 yum Repository.
 You can find the yum reference at the following path:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://archive.cloudera.com/cdh5/redhat/5/x86_64/cdh/cloudera-cdh5.repo"

\end_inset


\begin_inset Newline newline
\end_inset

Just copy the dowloaded file into the 
\emph on
/etc/yum.repos.d 
\emph default
directory and type 
\emph on
sudo yum update 
\emph default
as root user.
\end_layout

\begin_layout Enumerate
SSH key passwordless authentication must be configured for root account
 for all target hosts.
 The default configuration of PoliCloud was ok, but it was needed to add
 the access key to the known hosts of the root user.
\end_layout

\begin_layout Enumerate
SeLinux must be disabled
\end_layout

\begin_layout Enumerate
Ansible and unzip on the machine that runs the script.
 We ran the script on Master node.
 It is required to set 
\emph on
remote_user = root 
\emph default
in 
\emph on
/etc/ansible/ansible.cfg
\emph default
 file.
 Moreover, logging can be enabled setting the correct flag in the ansible.cfg
 file.
\end_layout

\begin_layout Standard
Algorithm 2 can be run on every machine to set points 2,3,4 and 5.
 The reboot is needed to let the SeLinux deactivation apply.
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=bash,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#enter root environment
\end_layout

\begin_layout Plain Layout

sudo su -
\end_layout

\begin_layout Plain Layout

#add misc epel-release
\end_layout

\begin_layout Plain Layout

yum install epel-release unzip wget -y
\end_layout

\begin_layout Plain Layout

#download and install cloudera repo reference 
\end_layout

\begin_layout Plain Layout

wget -nc https://archive.cloudera.com/cdh5/redhat/6/x86_64/cdh/cloudera-cdh5.repo
\end_layout

\begin_layout Plain Layout

mv -f cloudera-cdh5.repo /etc/yum.repos.d/cloudera-cdh5.repo yum update -y
\end_layout

\begin_layout Plain Layout

#get Oracle Java and install it 
\end_layout

\begin_layout Plain Layout

wget -nc --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2
F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http://download.o
racle.com/otn-pub/java/jdk/8u121-b13/e9e7ea248e2c4826b92b3f075a80e441/jdk-8u121-l
inux-x64.rpm" 
\end_layout

\begin_layout Plain Layout

yum localinstall jdk-8u121-linux-x64.rpm -y
\end_layout

\begin_layout Plain Layout

#enable root login with centos user key
\end_layout

\begin_layout Plain Layout

#this is a simple turnaround: copy the authorized keys of the user centos
 and make them ok also for root user
\end_layout

\begin_layout Plain Layout

/bin/cp -f /home/centos/.ssh/authorized_keys ~/.ssh/authorized_keys
\end_layout

\begin_layout Plain Layout

#restart ssh deamon
\end_layout

\begin_layout Plain Layout

service sshd restart
\end_layout

\begin_layout Plain Layout

#disable selinux 
\end_layout

\begin_layout Plain Layout

echo "SELINUX=disabled" > /etc/selinux/config 
\end_layout

\begin_layout Plain Layout

echo "SELINUXTYPE=targeted" >> /etc/selinux/config 
\end_layout

\begin_layout Plain Layout

#reboot the system
\end_layout

\begin_layout Plain Layout

reboot
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Environment setup script
\end_layout

\end_inset


\end_layout

\end_inset

Ansible must be installed manually.
 It is in the 
\emph on
epel-release 
\emph default
repository.
 This repository was added by the above script, so after you run the script
 on Master just type the following command:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sudo yum install ansible -y
\end_layout

\end_inset

and set the 
\emph on
remote_user 
\emph default
flag as explained before.
\end_layout

\begin_layout Subsubsection
Memory Partitions and Volumes
\end_layout

\begin_layout Standard
The available CentOS image created just a single partition of 8GB, so the
 disk associated to an instance was not fully utilized.
 This amount of memory was obviously not sufficient for our tests, so we
 needed to add some storage memory to the instances.
 We employed the volume utility of PoliCloud.
 It is possible to create virtual disks.
 The property of these disks is that the memory is persistent: what is saved
 on a volume 
\begin_inset Quotes eld
\end_inset


\emph on
persists
\emph default

\begin_inset Quotes erd
\end_inset

 until the disk is deleted (useful but not needed feature in our case)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Default disks of the instances don't have the persistent property.
 That's why they're called 
\emph on
ephemeral.
\end_layout

\end_inset

.
 We attached a volume of 50GB to each instance.
 We also created a swap partition for each instance exploiting a part of
 the unoccupied disk it using 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "cfdisk"
target "https://linux.die.net/man/8/cfdisk"

\end_inset

 
\emph default
(a partition editor for linux).
 Algorithm 3,4,5 and 6 should perform the needed tasks.
 Algorithm 3 and 4 must be executed on Master and also on workers, then
 run Algorithm 5 on Master and Algorithm 6 on every worker.
 Note that algorithms 5 and 6 are intended as a continuation of Algorithm
 4.
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#from PoliCloud dashboard create a volume and associate
\end_layout

\begin_layout Plain Layout

# it to the instance
\end_layout

\begin_layout Plain Layout

#enter root environment
\end_layout

\begin_layout Plain Layout

sudo su -
\end_layout

\begin_layout Plain Layout

#call cfdisk on the virtual disk of the instance
\end_layout

\begin_layout Plain Layout

#create a partition that will become the swap (/dev/sda2)
\end_layout

\begin_layout Plain Layout

#and one partition with the remaining space (/dev/sda3)
\end_layout

\begin_layout Plain Layout

cfdisk /dev/sda
\end_layout

\begin_layout Plain Layout

#call cfdisk on the volume
\end_layout

\begin_layout Plain Layout

#for Master just create one big partition (/dev/sdb1)
\end_layout

\begin_layout Plain Layout

#for workers create 2 paritions: 
\end_layout

\begin_layout Plain Layout

# - 1 for yarn 28GB big (/dev/sdb1)
\end_layout

\begin_layout Plain Layout

# - 1 for hdfs with the remaining space (/dev/sdb2)
\end_layout

\begin_layout Plain Layout

cfdisk /dev/sdb
\end_layout

\begin_layout Plain Layout

#reboot to detect partitions
\end_layout

\begin_layout Plain Layout

reboot
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Memory setup on an instance (Part 1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!bin/bash
\end_layout

\begin_layout Plain Layout

#!!WARNING!!
\end_layout

\begin_layout Plain Layout

#!! After the reboot the name of disks may be swapped:
\end_layout

\begin_layout Plain Layout

#!! /dev/sda may become /dev/sdb and viceversa
\end_layout

\begin_layout Plain Layout

#!! Always check this fact.
 If the names are swapped
\end_layout

\begin_layout Plain Layout

#!! change the below commands where needed
\end_layout

\begin_layout Plain Layout

#!! Now we assume that /dev/sda and /dev/sdb are the 
\end_layout

\begin_layout Plain Layout

#!! same as the Algorithm 3, Part1
\end_layout

\begin_layout Plain Layout

#enter root environment
\end_layout

\begin_layout Plain Layout

sudo su -
\end_layout

\begin_layout Plain Layout

#format swap and mount it
\end_layout

\begin_layout Plain Layout

mkswap /dev/sda2
\end_layout

\begin_layout Plain Layout

swapon /dev/sda2
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Memory setup on an instance (Part 2, after the reboot, common part)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#CHECK Algorithm 4 WARNING
\end_layout

\begin_layout Plain Layout

#format volume and mount it
\end_layout

\begin_layout Plain Layout

#this partition will be used for hdfs
\end_layout

\begin_layout Plain Layout

mkfs.ext4 /dev/sdb1
\end_layout

\begin_layout Plain Layout

#create path
\end_layout

\begin_layout Plain Layout

mkdir /var/lib/hadoop-hdfs
\end_layout

\begin_layout Plain Layout

#mount the partition ath the new path
\end_layout

\begin_layout Plain Layout

mount /dev/sdb1 /var/lib/hadoop-hdfs
\end_layout

\begin_layout Plain Layout

#do the same for /dev/sda3 and /var/lib/hadoop-yarn
\end_layout

\begin_layout Plain Layout

mkfs.ext4 /dev/sda3
\end_layout

\begin_layout Plain Layout

mkdir /var/lib/hadoop-yarn
\end_layout

\begin_layout Plain Layout

mount /dev/sda3 /var/lib/hadoop-yarn
\end_layout

\begin_layout Plain Layout

#exit root environment
\end_layout

\begin_layout Plain Layout

exit
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Memory setup on Master (Part 2, after the reboot)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#CHECK Algorithm 4 WARNING
\end_layout

\begin_layout Plain Layout

#format volume partitions 
\end_layout

\begin_layout Plain Layout

mkfs.ext4 /dev/sdb1
\end_layout

\begin_layout Plain Layout

mffs.ext4 /dev/sdb2
\end_layout

\begin_layout Plain Layout

#create paths
\end_layout

\begin_layout Plain Layout

mkdir /var/lib/hadoop-hdfs
\end_layout

\begin_layout Plain Layout

mkdir /var/lib/hadoop-yarn
\end_layout

\begin_layout Plain Layout

#mount the partitions
\end_layout

\begin_layout Plain Layout

mount /dev/sdb1 /var/lib/hadoop-hdfs
\end_layout

\begin_layout Plain Layout

mount /dev/sdb2 /var/lib/hadoop-yarn
\end_layout

\begin_layout Plain Layout

#exit root environment
\end_layout

\begin_layout Plain Layout

exit
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Memory setup on a worker (Part 2, after the reboot)
\end_layout

\end_inset


\end_layout

\end_inset

Now the instances should be ready to install the Hadoop environment.
\end_layout

\begin_layout Paragraph
WARNING ON MOUNTED PARTITIONS
\end_layout

\begin_layout Standard
The partitions are mounted, but we didn't altered the 
\emph on
/etc/fstab
\emph default
, which is the file that tells the OS which partitions mount at boot time.
 
\bar under
This means that after every reboot the partitions must be remounted
\bar default
.
\end_layout

\begin_layout Subsubsection
Ansible
\end_layout

\begin_layout Standard
Ansible is an open-source automation engine that automates cloud provisioning,
 configuration management, and application deployment.
 Once installed on a control node, Ansible, which is an agentless architecture,
 connects to a managed node through the default OpenSSH connection type.
 You can define a set of rules that can be executed in a specified order
 and when some conditions are met.
 The set of tasks and rules are specified in a playbook.
 The used script was very easy to use because there is a file called 
\emph on
hosts
\emph default
 that can be edited.
 In this file you can specify the hadoop roles of each machine (namenode,
 datanode) and which software you want to install (zookeeper, spark...).
 We installed a simple cluster with Master as namenode and datanode (it
 had enough computationl power to perform both tasks) and the workers as
 datanodes.
 The yarn resource manager was installed on Master.
 It is required to fix the file 
\emph on
group_vars/all 
\emph default
that contains some useful variables.
 The java path it is not correct so you must manually edit it.
 If you ran the provided script you just have to change the first two uncommente
d lines into the following ones:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

java_package: java-1.8.0 
\end_layout

\begin_layout Plain Layout

java_home: /usr/java/jdk1.8.0_121/ 
\end_layout

\end_inset

As described in the README of 
\emph on
sergevs
\emph default
 repository, run the script typing this command from the root directory
 of the repository:
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

ansible-playbook -i hosts site.yaml
\end_layout

\end_inset

If the installation is successful, then it's time to install Pig.
\end_layout

\begin_layout Subsubsection
Pig
\end_layout

\begin_layout Standard
Apache Pig is a high-level platform for creating programs that run on Apache
 Hadoop.
 The language for this platform is called Pig Latin.
 Pig can execute its Hadoop jobs in MapReduce, Apache Tez, or Apache Spark.
 Pig Latin abstracts the programming from the Java MapReduce idiom into
 a notation which makes MapReduce programming high level, similar to that
 of SQL for RDBMSs.
 Pig was not included in the playbook so we installed it manually after
 the playbook was executed using the Cloudera 5 Repository, just type the
 following command on Master:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sudo yum install pig
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
End of the Installation
\end_layout

\begin_layout Standard
At the end of the installation we should have an architecture that corresponds
 to the deployment diagram shown in Figure 1.
 To launch any task on the cluster just SSH the Master and in the 
\emph on
hdfs
\emph default
 user environment.
 To enter in such environment type the following command:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sudo su - hdfs
\end_layout

\end_inset


\end_layout

\begin_layout Section
Test Execution and Data Collection
\end_layout

\begin_layout Standard
As we have already stated before, the purpose of this work is to acquire
 a deeper awareness on how our cloud architecture scale.
 To achieve our goal we designed a test that consisted in repeatedly run
 a benchmark algorithm while progressively adding more resources to our
 cluster.
 We started with the just Master and two workers and we kept adding one
 worker at a time up to eight.
 The benchmark algorithm we chose is a classical matrix-multiplication algorithm.
 The algorithm multiplies the same square matrix by itself.
 In addition to scale on the dimension of the cluster we decided that would
 have been interesting also to scale on the dimension of the matrix, we
 chose a 500 rows by 500 column matrix before and a 1000 rows by 1000 column
 then.
 Note that we always used the same two matrices for every test.
 So, to sum up, we ran the following tests:
\end_layout

\begin_layout Enumerate
500 by 500 matrix on a 3-node cluster
\end_layout

\begin_layout Enumerate
500 by 500 matrix on a 4-node cluster
\end_layout

\begin_layout Enumerate
500 by 500 matrix on a 5-node cluster
\end_layout

\begin_layout Enumerate
500 by 500 matrix on a 6-node cluster
\end_layout

\begin_layout Enumerate
500 by 500 matrix on a 7-node cluster
\end_layout

\begin_layout Enumerate
500 by 500 matrix on a 8-node cluster
\end_layout

\begin_layout Enumerate
1000 by 1000 matrix on a 3-node cluster
\end_layout

\begin_layout Enumerate
1000 by 1000 matrix on a 4-node cluster
\end_layout

\begin_layout Enumerate
1000 by 1000 matrix on a 5-node cluster
\end_layout

\begin_layout Enumerate
1000 by 1000 matrix on a 6-node cluster
\end_layout

\begin_layout Enumerate
1000 by 1000 matrix on a 7-node cluster
\end_layout

\begin_layout Enumerate
1000 by 1000 matrix on a 8-node cluster
\end_layout

\begin_layout Standard
In order for our results to be consistent we run each of the just mentioned
 tests 10 times.
 Unfortunately, due to the significant amount of time required, we hadn't
 been able to run each test 30 times, as the common practice would suggest.
\end_layout

\begin_layout Subsection
Generation of the Matrices
\end_layout

\begin_layout Standard
We used a simple C program to generate a dense square matrix of size 
\emph on
DIMxDIM
\emph default
.
 The output format of the matrix was foreach line 
\emph on
<row 
\backslash
t column 
\backslash
t value>.
 
\emph default
The program uses OpenMP to speed up the generation of the matrix.
 To compile the source type the following command:
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

cc -fopenmp -DDIM=<matrix_side_length> genMatParallel.c -o genMatParallel
\end_layout

\end_inset

The 
\emph on
-fopenmp 
\emph default
flag enables the parallelism.
 Anyway if you can't use OpenMp you can compile the program without the
 specified flag.
 Remember to change 
\emph on
<matrix_side_length> 
\emph default
with any integer value.
 After the compilation run the executable to generate the 
\emph on
outMatrix.txt 
\emph default
file, which contains the matrix.
 In our case we set DIM to 500 and then 1000.
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C,tabsize=3"
inline false
status open

\begin_layout Plain Layout

#ifndef DIM
\end_layout

\begin_layout Plain Layout

#define DIM 10
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifndef FILE_PATH
\end_layout

\begin_layout Plain Layout

#define FILE_PATH "outMatrix.txt"
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <omp.h>
\end_layout

\begin_layout Plain Layout

#include <time.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

       FILE * fp = fopen(FILE_PATH,"w");
\end_layout

\begin_layout Plain Layout

       srand( (unsigned int) time(NULL));
\end_layout

\begin_layout Plain Layout

       int i,j;
\end_layout

\begin_layout Plain Layout

       #pragma omp parallel for collapse(2) private(i,j)
\end_layout

\begin_layout Plain Layout

       for(i=0; i<DIM; i++)
\end_layout

\begin_layout Plain Layout

       {
\end_layout

\begin_layout Plain Layout

			for(j=0; j<DIM; j++)
\end_layout

\begin_layout Plain Layout

                {
\end_layout

\begin_layout Plain Layout

                        int random = rand();
\end_layout

\begin_layout Plain Layout

                        fprintf(fp, "%d
\backslash
t%d
\backslash
t%d
\backslash
n", i,j, random);
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    	fclose(fp);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Matrix generation source
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Test Script
\end_layout

\begin_layout Standard
The Pig Latin script shown in Algorithm 8 performs the multiplication.
 Since our goal was to run a benchmark and not to actually multiply matrices
 we didn't bother to choose a particularly efficient implementaion and thus
 we went for the classical naive school-book algorithm with time complexity
 
\begin_inset Formula $O(n^{3})$
\end_inset

.
 
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Perl,numbers=left,breaklines=true,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

SET default_parallel n;
\end_layout

\begin_layout Plain Layout

matrix1 = LOAD 'mat1' AS (row,col,value);
\end_layout

\begin_layout Plain Layout

matrix2 = LOAD 'mat1' AS (row,col,value);
\end_layout

\begin_layout Plain Layout

A = JOIN matrix1 BY col FULL OUTER, matrix2 BY row;
\end_layout

\begin_layout Plain Layout

B = FOREACH A GENERATE matrix1::row AS m1r, matrix2::col AS m2c, (matrix1::value
)*(matrix2::value) AS value;
\end_layout

\begin_layout Plain Layout

C = GROUP B BY (m1r, m2c);
\end_layout

\begin_layout Plain Layout

multiplied_matrices = FOREACH C GENERATE group.$0 as row, group.$1 as col,
 SUM(B.value) AS val;
\end_layout

\begin_layout Plain Layout

store multiplied_matrices into 'matmul_out'; 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The test script in Pig Latin
\end_layout

\end_inset


\end_layout

\end_inset

Algorithm 9 is just a wrapper of Algorithm 8: It iterates 10 times (this
 is the number of our repetitions set for each test case) for each matrix
 (so once for 500 and once for 1000) and it prepares the environment by
 cleaning the hdfs, copying the test matrix and launching Algorithm 8.
 Algorithm 9 also generate a file where it stores for each line timestamp,
 test matrix , number of nodes and execution time.
 This will be helpful in log processing.
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=bash,numbers=left,breaklines=true,tabsize=3,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#init variables
\end_layout

\begin_layout Plain Layout

matrices_dir="matrices_dir"
\end_layout

\begin_layout Plain Layout

HDFS_MATRIX_NAME="mat1"
\end_layout

\begin_layout Plain Layout

PIG_EXEC="matmul.pig"
\end_layout

\begin_layout Plain Layout

HDFS_OUT_DIR="matmul_out"
\end_layout

\begin_layout Plain Layout

output_dir="test_output"
\end_layout

\begin_layout Plain Layout

all_time_storage="$output_dir/pig_times.txt"
\end_layout

\begin_layout Plain Layout

time_buf_file="tmp/time_buf"
\end_layout

\begin_layout Plain Layout

#get the number of workers
\end_layout

\begin_layout Plain Layout

n_datanodes=`hdfs dfsadmin -report | grep Live | tr -d -c 0-9`
\end_layout

\begin_layout Plain Layout

#do the test for every matrix in $matrices_dir
\end_layout

\begin_layout Plain Layout

for matrix in `ls $matrices_dir`
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	#do the test 10 times
\end_layout

\begin_layout Plain Layout

	for iter in `seq 1 10`
\end_layout

\begin_layout Plain Layout

	do
\end_layout

\begin_layout Plain Layout

		#PREPARE THE ENVIRONMENT
\end_layout

\begin_layout Plain Layout

		timestamp=`date -Iseconds`
\end_layout

\begin_layout Plain Layout

		output_file=$output_dir/$matrix-$timestamp
\end_layout

\begin_layout Plain Layout

		#copy test matrix ind hdfs
\end_layout

\begin_layout Plain Layout

		hadoop fs -copyFromLocal -f $matrices_dir/$matrix $HDFS_MATRIX_NAME
\end_layout

\begin_layout Plain Layout

		#clean old results that could be present in hdfs
\end_layout

\begin_layout Plain Layout

		hadoop fs -rm -r -f $HDFS_OUT_DIR
\end_layout

\begin_layout Plain Layout

		#RUN THE TEST
\end_layout

\begin_layout Plain Layout

		#use unix time command, not the one of bash to estimate pig exec_time
\end_layout

\begin_layout Plain Layout

		#redirect pig output in $output_file
\end_layout

\begin_layout Plain Layout

		/usr/bin/time -f %e -o $time_buf_file pig $PIG_EXEC |& tee $output_file
\end_layout

\begin_layout Plain Layout

		pig_time=$(cat $time_buf_file)
\end_layout

\begin_layout Plain Layout

		#save exec_time in pig_times.txt
\end_layout

\begin_layout Plain Layout

		echo "$timestamp,$matrix,$n_datanodes,$pig_time" >> $all_time_storage
\end_layout

\begin_layout Plain Layout

	done
\end_layout

\begin_layout Plain Layout

done 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wrapper of the basic test script
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Log Processing
\end_layout

\begin_layout Standard
Algorithm 10 has been used to mine yarn logs of each node.
 Raw logs can be found at the link cited at Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Reference-Links"

\end_inset

.
 This script generates an output file at the path specified by 
\emph on
$log_times 
\emph default
where it stores app_id of a job, the name of the node and the execution
 time.
 The script mines 
\emph on
app_id
\emph default
s from the logs obtained by pig executions contained inf the directory 
\emph on
$pig_log_dir.
 
\emph default
For every found 
\emph on
app_id 
\emph default
it searches for occurrence in every yarn log.
 A yarn log is uniquely associated to a node.
 By getting the timestamp of the first and the last occurence it is easy
 to compute the execution time.
 Check the code and the comments to understand better how the Algorithm
 10 works.
\end_layout

\begin_layout Paragraph
NOTE
\end_layout

\begin_layout Standard
Algorithm 10 were run with AWK=4.1.4.
 Different versions may not work.
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=bash,numbers=left,breaklines=true,tabsize=3"
inline false
status open

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#Recognize dates with a regex
\end_layout

\begin_layout Plain Layout

DATE_REGEX="2017-[0-1][0-9]-[0-3][0-9]
\backslash
s[0-2][0-9]
\backslash
:[0-5][0-9]
\backslash
:[0-5][0-9]"
\end_layout

\begin_layout Plain Layout

#path variables
\end_layout

\begin_layout Plain Layout

yarn_log_dir="yarn_logs"
\end_layout

\begin_layout Plain Layout

pig_log_dir="pig_logs"
\end_layout

\begin_layout Plain Layout

tmp_file="tmp.txt"
\end_layout

\begin_layout Plain Layout

log_times="log_times.csv"
\end_layout

\begin_layout Plain Layout

for pig_log in `ls $pig_log_dir`
\end_layout

\begin_layout Plain Layout

do
\end_layout

\begin_layout Plain Layout

	#app_ids have the following regex: [0-9]{13}_[0-9]{4} 
\end_layout

\begin_layout Plain Layout

	#use awk to find occurrences in $pig_log_dir/$pig_log.
 
\end_layout

\begin_layout Plain Layout

	#remove duplicates with pipe combination of sort and unique 
\end_layout

\begin_layout Plain Layout

	app_id_ar=`awk 'match($0,/[0-9]{13}_[0-9]{4}/){ print substr($0,RSTART,RLENGTH)
}' ./"$pig_log_dir/$pig_log" | sort | uniq`
\end_layout

\begin_layout Plain Layout

	for app_id in $app_id_ar
\end_layout

\begin_layout Plain Layout

	do
\end_layout

\begin_layout Plain Layout

		for yarn_worker_log in `ls $yarn_log_dir`
\end_layout

\begin_layout Plain Layout

		do
\end_layout

\begin_layout Plain Layout

			#just get timestamp of the first and the last occurrence 
\end_layout

\begin_layout Plain Layout

			#of $app_id, convert them in seconds and substract them
\end_layout

\begin_layout Plain Layout

			#to obtain the execution time
\end_layout

\begin_layout Plain Layout

			grep $app_id $yarn_log_dir/$yarn_worker_log > $tmp_file
\end_layout

\begin_layout Plain Layout

			first_occ=`head $tmp_file -n 1`
\end_layout

\begin_layout Plain Layout

			first_time=`echo "$first_occ" | grep -o $DATE_REGEX`
\end_layout

\begin_layout Plain Layout

			first_time_sec=`date --date="$first_time" +%s`
\end_layout

\begin_layout Plain Layout

			last_time=`tail $tmp_file -n 1 | grep -o $DATE_REGEX`
\end_layout

\begin_layout Plain Layout

			last_time_sec=`date --date="$last_time" +%s`
\end_layout

\begin_layout Plain Layout

			exec_time=`expr $last_time_sec - $first_time_sec`
\end_layout

\begin_layout Plain Layout

			echo "$app_id,$yarn_worker_log,$exec_time" >> $log_times
\end_layout

\begin_layout Plain Layout

		done
\end_layout

\begin_layout Plain Layout

	done
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout

rm $tmp_file
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Yarn miner script
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Log Files
\end_layout

\begin_layout Standard
On the GitHub repository of the project, in addition to the original log
 files, we have pushed also some other files that contains a cleaner and
 more human readable version of the original log files.
 These files are the following:
\end_layout

\begin_layout Description
pig_matrix-mul_coarse.csv contains extremely aggregated data.
 There is one row for each group of test (i.e.
 one row for each cluster dimension for each matrix dimension).
 In addition to the mean total time we have included also some statistics
 such as median and standard deviation.
\end_layout

\begin_layout Description
pig_matrix-mul_fine.csv contains aggregated data for each test.
 For each of test 120 we ran we have reported some statistics for each one
 of the two jobs that compose each test.
 Check Appendix B for header interpretation.
\end_layout

\begin_layout Description
pig_matrix-mul_extra-fine.csv contains a finer graned version of 
\emph on
pig_matrix-mul_fine.csv
\emph default
.
 The execution times on each worker are also reported for each job of each
 test.
\end_layout

\begin_layout Standard
The above described files are the result of the combination of pig_logs
 (contained in the linked zipped folder), 
\emph on
pig_times.txt
\emph default
 and 
\emph on
log_times.csv
\emph default
 (contained in the repository 
\emph on
log 
\emph default
folder).
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard
Figure 2 shows the total execution times with both matrices w.r.t.
 the different cluster dimensions.
 We decided to use a boxplot for the representation because in a single
 plot are included a lot of information about the distribution of the results
 along the test.
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/box_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/box_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot of the results
\end_layout

\end_inset


\end_layout

\end_inset

Representations of execution times on each worker can be found in Appendix
 A.
 Figure 3 shows the speed-up obtained from increasing the datanodes from
 3 to 8.
 We considered as 
\begin_inset Quotes eld
\end_inset

base case
\begin_inset Quotes erd
\end_inset

 the execution time of the algorithm with 3 nodes.
 Figure 4 has been obtained by overlapping the graphs contained in Appendix
 A.
 It is easy to observe that, for each job, lines are 
\begin_inset Quotes eld
\end_inset

well overlapped
\begin_inset Quotes erd
\end_inset

 for the 1000x1000 matrix.
 This means that the time to end one job is equal on each node.
 The graph of the tests with the matrix 500x500 is more confusing: this
 means that on each machine the execution time per job is more variable.
 
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/speedup_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/speedup_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Speed-up 1000x1000 matrix
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/global_job_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/global_job_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Graph obtained by overlapping of the graphs of the Appendix A
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
As one would expect, by increasing the number of working nodes the time
 required for the algorithm to complete decreases.
 In our opinion, the interruption of this decreasing trend after the addition
 of the seventh worker can be explained with the fact that we don't really
 know how OpenStack allocates the instances and where these instances are
 physically located.
 The fact that this worsening is more empasized with the 500 by 500 matrix
 can be addressed by the different ratio between the time required for the
 management of the workers and the time of actual computation.
 As future work we suggest to retake the tests, in fact, the degradation
 in the performance could be also due to a temporal excess load on the PoliCloud
 at that time.
 We would also suggest to continue adding more machines, beyond eight, and
 see how the scaling behaves.
 Regarding PoliCloud usability, it is very easy to use, but some bugs on
 the infrastrucutre slowed down the work: [
\begin_inset Quotes eld
\end_inset

OLTRE AL BUG DI SSH PRIMA CITATO
\begin_inset Quotes erd
\end_inset

 NON SO COME SI SCRIVE IN INGLESE], the action of deleting instances generates
 error sometimes.
 After this event, the inquired instance can only be deleted by the system
 administrator.
 The main problems that we had to face during installation were the correct
 sizing of the storage space of the instances w.r.t the size of the test matrces.
 We had a cap of maximum storage memory that we needed to part.
 Too small matrix would not be significant, but too big would have run out
 of memory the partition of the nodes making the nodes unhealthy or filling
 the swap, blocking the entire test case.
 
\emph on
sergevs
\emph default
' tool is quite powerful.
 We just used a small part of its potential.
\end_layout

\begin_layout Section
\start_of_appendix
Execution Time per Job Graphs
\end_layout

\begin_layout Standard
Each figure shows the average execution time on a node w.r.t.
 the dimension of the cluster.
 The times for each of the two jobs that compose a test are represented
 separately in the plot.
 Plots realted to worker3 and successive start from 4 workers up to 8 because
 Worker3 is used only when the dimension of the cluster is greater than
 3.
 A similar rule is applied also for successive workers.
 The graphs for Worker7 are not significant because they're just a bunch
 of points, so they've been replaced by Table 1.
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_ma_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_ma_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Master
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_w1_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_w1_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker1
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_w2_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_w2_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker2
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_w3_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_w3_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker3
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_w4_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_w4_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker4
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_w5_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_w5_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker5
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename img/job_w6_m500.png
	width 8cm

\end_inset


\begin_inset Graphics
	filename img/job_w6_m1000.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker6
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
500
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
job
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time[s]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color blue
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
124.6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color orange
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
410.4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
job
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
time[s]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color blue
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1170.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\color orange
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2580.8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time per job on Worker7
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Header Legend
\end_layout

\begin_layout Standard
The header of the file 
\emph on
pig_matrix-mul_fine.csv
\emph default
 cited in Section 3.4 is composed as follows:
\end_layout

\begin_layout Itemize
Nodes: the number of datanodes we were using;
\end_layout

\begin_layout Itemize
Dim: the dimension of the matrix (either 500 or 1000);
\end_layout

\begin_layout Itemize
Test: a number that goes from 1 to 10 that represents the number of the
 test for a given cluster dimension and matrix dimension;
\end_layout

\begin_layout Itemize
Job: since each test is composed of two jobs this value can be either 1
 or 2;
\end_layout

\begin_layout Itemize
JobId: a unique job identification number;
\end_layout

\begin_layout Itemize
Maps: number of maps of this job (this value depends on the dimension of
 the input);
\end_layout

\begin_layout Itemize
Reduces: number of reduces of this job (this value depends on the number
 datanodes);
\end_layout

\begin_layout Itemize
MaxMapTime: time of the map that took more time;
\end_layout

\begin_layout Itemize
MinMapTIme: time of the map that took less time;
\end_layout

\begin_layout Itemize
AvgMapTime: average map time;
\end_layout

\begin_layout Itemize
MedianMapTime: median map time;
\end_layout

\begin_layout Itemize
MaxReduceTime: time of the reduce that took more time;
\end_layout

\begin_layout Itemize
MinReduceTime: time of the reduce that took less time;
\end_layout

\begin_layout Itemize
AvgReduceTime: average reduce time;
\end_layout

\begin_layout Itemize
MedianReducetime: median reduce time;
\end_layout

\begin_layout Itemize
Alias: 
\begin_inset Quotes erd
\end_inset

variables
\begin_inset Quotes erd
\end_inset

 of the pig latin script used for this job;
\end_layout

\begin_layout Itemize
Feature: operations performed in this job;
\end_layout

\begin_layout Itemize
Date;
\end_layout

\begin_layout Itemize
Time: total time for the test (job1 + job2)
\end_layout

\begin_layout Section
Structure of the Repository
\end_layout

\begin_layout Standard
The 
\emph on
doc
\emph default
 folder contains this document and the images required from it.
 The 
\emph on
log
\emph default
 folder contains the obtained logs in 
\emph on
csv 
\emph default
format.
 The 
\emph on
src 
\emph default
folder contains all the scripts used in the project.
 These scripts are well described in this document and they're organized
 in subfolders.
\end_layout

\end_body
\end_document
